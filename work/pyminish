#!/usr/bin/env python3

import os
import sys
import signal

# print("hello")

### 内部コマンド実装 ###


def builtin_echo(args):
    print(" ".join(args))


def builtin_exit(args):
    exit()

### コマンドを探す関数 ###


def find_command(command):
    for path_dir in os.environ["PATH"].split(":"):
        command_path = os.path.join(path_dir, command)
        # コマンドが存在して、かつディレクトリでない場合
        if os.path.exists(command_path) and not os.path.isdir(command_path):
            # コマンドのパスを返す
            return command_path
    return None


BUILTIN_COMMAND_FUNC_MAPPONG = {
    "echo": builtin_echo,  # 上部で定義した関数の紐付け
    "exit": builtin_exit,
}

### 内部コマンド実装 END ###


### SIGINT ハンドラー実装 ###
def sigint_handler():
    pass

### SIGINT ハンドラー実装 END ###

### コマンド処理 ###
def interpret_line(line):

    tokens = line.split()
      
    # コマンドが空の場合は無視
    if len(tokens) == 0:
        return

    command = tokens[0]  # コマンド部分
    args = tokens[1:]  # 引数部分

    # TODO コマンドを実行する
    if command in BUILTIN_COMMAND_FUNC_MAPPONG:
        # コマンドに対応する関数を取得して実行
        func = BUILTIN_COMMAND_FUNC_MAPPONG[command]
        func(args)
    else:
        # 外部コマンドの処理
        command_path = find_command(command)

        # コマンドが見つからなかった場合
        if command_path is None:
            print(f"{command}: command not found", file=sys.stderr)
            return

        ### プロセスの実行 ###
        pid = os.fork()  # プロセスの複製

        if pid == 0:
            # 子プロセス 処理
            command_basename = os.path.basename(command_path)
            os.execv(command_path, [command_basename] + args)
          #  os.execv(command_path, [command_basename] + args, os.environ)
        else:
            # 親プロセス 処理
            os.waitpid(pid, 0)  # 子プロセスの終了を待機

### コマンド処理　END ###


def main():
    
    ### シェルスクリプト、実行 ###
    if len(sys.argv) >= 2:
        file_name = sys.argv[1]
    else:
        file_name = None
    
    if file_name is None:
        
         # Ctrl + c の SIGINTの挙動を変更
        signal.signal(signal.SIGINT, sigint_handler)
        
        # 通常シェル操作の場合
        while True:
            # 入力値
            line = input("> ")
          
            ### コマンド処理 interpret_line ###
            interpret_line(line)
            
    else:
        # シェルスクリプトの場合
        with open(file_name) as f:
            for line in f:
                interpret_line(line)
   


if __name__ == "__main__":
    main()
